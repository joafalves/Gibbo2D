<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Gibbo.Library</name>
    </assembly>
    <members>
        <member name="T:Gibbo.Library.Info">
            <summary>
            Attribute that adds an information attribute to the component.
            </summary>
        </member>
        <member name="M:Gibbo.Library.Info.#ctor(System.String)">
            <summary>
            Creates a new Info
            </summary>
            <param name="info">The information you want to be displayed</param>
        </member>
        <member name="T:Gibbo.Library.RequireComponent">
            <summary>
            Attribute that adds one or more component requirements to the object.
            </summary>
        </member>
        <member name="M:Gibbo.Library.RequireComponent.#ctor(System.String,System.Boolean)">
            <summary>
            Requirement based on the type name(s)
            </summary>
            <param name="componentTypeNames">The type name, if you want to apply multiple requirements use '|' to split them.</param>
            <param name="requireAll">If true every component is required</param>
        </member>
        <member name="T:Gibbo.Library.Unique">
            <summary>
            Attribute to determine if a component should have only 1 instance per object (explicit or assignable from)
            </summary>
        </member>
        <member name="M:Gibbo.Library.Unique.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.Unique.#ctor(Gibbo.Library.Unique.UniqueOptions)">
            <summary>
            
            </summary>
            <param name="options"></param>
        </member>
        <member name="T:Gibbo.Library.Unique.UniqueOptions">
            <summary>
            'Explicit' is the component type itself.
            'AssinableFrom' can be assigned from parent too (for example, is subclass of the component).
            </summary>
        </member>
        <member name="T:Gibbo.Library.ConstantTween">
            <summary>
            
            </summary>
        </member>
        <member name="T:Gibbo.Library.ITween">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.ITween.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Gibbo.Library.ConstantTween.#ctor(Gibbo.Library.GameObject)">
            <summary>
            
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Gibbo.Library.ConstantTween.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Gibbo.Library.ConstantTween.To(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="rate"></param>
            <param name="initialDelay"></param>
        </member>
        <member name="M:Gibbo.Library.ConstantTween.To(Gibbo.Library.Transform,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="targetTransform"></param>
            <param name="rate"></param>
            <param name="initialDelay"></param>
        </member>
        <member name="E:Gibbo.Library.ConstantTween.TweenCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="E:Gibbo.Library.ConstantTween.TweenStarted">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.ConstantTween.InitialTransform">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.ConstantTween.Loop">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.ConstantTween.Target">
            <summary>
            
            </summary>
        </member>
        <member name="T:Gibbo.Library.Tween">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.Tween.#ctor(Gibbo.Library.GameObject)">
            <summary>
            
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:Gibbo.Library.Tween.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Gibbo.Library.Tween.To(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="duration"></param>
            <param name="initialDelay"></param>
        </member>
        <member name="M:Gibbo.Library.Tween.To(Gibbo.Library.Transform,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="targetTransform"></param>
            <param name="duration"></param>
            <param name="initialDelay"></param>
        </member>
        <member name="E:Gibbo.Library.Tween.TweenCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="E:Gibbo.Library.Tween.TweenStarted">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tween.InitialTransform">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tween.Loop">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tween.Target">
            <summary>
            
            </summary>
        </member>
        <member name="T:Gibbo.Library.CircleBody">
            <summary>
            Circle Body
            </summary>
        </member>
        <member name="T:Gibbo.Library.PhysicalBody">
            <summary>
            Physical body
            </summary>
        </member>
        <member name="T:Gibbo.Library.ExtendedObjectComponent">
            <summary>
            Class used if you want object components to update and draw in the editor.
            </summary>
        </member>
        <member name="T:Gibbo.Library.ObjectComponent">
            <summary>
            This class represents one object component.
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.Removed">
            <summary>
            Virtual Removed.
            This method is called when the script is removed from the game object.
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.Initialize">
            <summary>
            Virtual Initialize
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Virtual Update
            </summary>
            <param name="gameTime">The game time</param>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Virtual Draw
            </summary>
            <param name="gameTime">The game time</param>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseDown(Gibbo.Library.MouseEventButton)">
            <summary>
            Virtual OnMouseDown Event
            Event thrown when there is a mouse click collision
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseClick(Gibbo.Library.MouseEventButton)">
            <summary>
            Virtual OnMouseClick Event
            Event thrown when there is a mouse click collision
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseUp">
            <summary>
            Event thrown when the mouse up event on the game object is triggered
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseOut">
            <summary>
            Event thrown when the mouse is not over the object
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseMove">
            <summary>
            Virtual OnMouseMove Event
            Event thrown when there is a mouse move collision
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnMouseEnter">
            <summary>
            Virtual OnMouseEnter Event
            Event thrown when the mouse enters in collision with the game object
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnCollisionEnter(Gibbo.Library.GameObject)">
            <summary>
            Virtual OnCollisionEnter Event
            Event thrown when there is an object collision.
            </summary>
            <param name="other">The collided object</param>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.OnCollisionFree">
            <summary>
            Virtual OnCollisionEnter Event
            Event thrown in a frame where there is no collision with other objects
            </summary>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.ToString">
            <summary>
            To String
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.ObjectComponent.Clone">
            <summary>
            Clone this object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Gibbo.Library.ObjectComponent.Disabled">
            <summary>
            Determines if the component is disabled
            </summary>
        </member>
        <member name="P:Gibbo.Library.ObjectComponent.Name">
            <summary>
            The name of the component
            </summary>
        </member>
        <member name="P:Gibbo.Library.ObjectComponent.EditorExpanded">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.ObjectComponent.Transform">
            <summary>
            The reference transform of the component's object 
            </summary>
        </member>
        <member name="M:Gibbo.Library.PhysicalBody.Initialize">
            <summary>
            Initializes the body
            </summary>
        </member>
        <member name="M:Gibbo.Library.PhysicalBody.Removed">
            <summary>
            Removes the body from the world when the component is removed
            </summary>
        </member>
        <member name="M:Gibbo.Library.PhysicalBody.UpdateBodyProperties">
            <summary>
            Update the body properties
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.LinearDamping">
            <summary>
            The linear damping of the object
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.IsBullet">
            <summary>
            Determines if the body is a bullet
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.IgnoreGravity">
            <summary>
            Determines if the body should ignore gravity
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.AngularVelocity">
            <summary>
            The angular velocity of the object
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.AngularDamping">
            <summary>
            The angular damping of the object
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.IsSensor">
            <summary>
            Determines if the body should behave as a sensor
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.FixedRotation">
            <summary>
            Determines if the body has a fixed rotation
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.Friction">
            <summary>
            The friction of the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.Restitution">
            <summary>
            The restitution of the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.PhysicalBody.BodyType">
            <summary>
            The body type
            </summary>
        </member>
        <member name="M:Gibbo.Library.CircleBody.Initialize">
            <summary>
            Initializes the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.CircleBody.Radius">
            <summary>
            The density of the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.CircleBody.Density">
            <summary>
            The density of the body
            </summary>
        </member>
        <member name="T:Gibbo.Library.RectangleBody">
            <summary>
            Rectangle Body
            </summary>
        </member>
        <member name="M:Gibbo.Library.RectangleBody.Initialize">
            <summary>
            Initializes the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.RectangleBody.Density">
            <summary>
            The density of the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.RectangleBody.Width">
            <summary>
            The Width of the body shape
            </summary>
        </member>
        <member name="P:Gibbo.Library.RectangleBody.Height">
            <summary>
            The Height of the body shape
            </summary>
        </member>
        <member name="T:Gibbo.Library.TextureBody">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.TextureBody.Initialize">
            <summary>
            Initializes the body
            </summary>
        </member>
        <member name="P:Gibbo.Library.TextureBody.ImageName">
            <summary>
            The relative path to the texture
            </summary>
        </member>
        <member name="P:Gibbo.Library.TextureBody.Density">
            <summary>
            The density of the body
            </summary>
        </member>
        <member name="T:FarseerPhysics.DebugViewBase">
            Implement and register this class with a World to provide debug drawing of physics
            entities in your game.
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.AppendFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Append flags to the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.RemoveFlags(FarseerPhysics.DebugViewFlags)">
            <summary>
            Remove flags from the current flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Draw a closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawSolidPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid closed polygon provided in CCW order.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="count">The vertex count.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawCircle(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draw a circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawSolidCircle(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a solid circle.
            </summary>
            <param name="center">The center.</param>
            <param name="radius">The radius.</param>
            <param name="axis">The axis.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Draw a line segment.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="red">The red value.</param>
            <param name="blue">The blue value.</param>
            <param name="green">The green value.</param>
        </member>
        <member name="M:FarseerPhysics.DebugViewBase.DrawTransform(FarseerPhysics.Common.Transform@)">
            <summary>
            Draw a transform. Choose your own length scale.
            </summary>
            <param name="transform">The transform.</param>
        </member>
        <member name="P:FarseerPhysics.DebugViewBase.Flags">
            <summary>
            Gets or sets the debug view flags.
            </summary>
            <value>The flags.</value>
        </member>
        <member name="M:FarseerPhysics.DebugView.DebugView2D.DrawDebugData">
            <summary>
            Call this to draw shapes and other debug draw data.
            </summary>
        </member>
        <member name="M:Gibbo.Library.ExtensionMethods.Rotate(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Rotates around an angle
            </summary>
            <param name="vector"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.ExtensionMethods.Intersects(Microsoft.Xna.Framework.Rectangle,Gibbo.Library.RotatedRectangle)">
            <summary>
            
            </summary>
            <param name="r"></param>
            <param name="rectangle"></param>
            <returns></returns>
        </member>
        <member name="T:Gibbo.Library.FontLoader">
            <summary>
            Font Loader
            </summary>
        </member>
        <member name="M:Gibbo.Library.FontLoader.Load(System.String)">
            <summary>
            Loads a font from a file path
            </summary>
            <param name="filename">The file path</param>
            <returns>Loaded font file</returns>
        </member>
        <member name="M:Gibbo.Library.FontLoader.Load(System.IO.Stream)">
            <summary>
            Loads a font from a stream
            </summary>
            <param name="stream">The stream</param>
            <returns>Loaded font file</returns>
        </member>
        <member name="T:Gibbo.Library.Classes.BMFontLoader">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.Classes.BMFontLoader.AddBMFont(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fntFilePath"></param>
            <param name="fontTexturePath"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Classes.BMFontLoader.Clear">
            <summary>
            Clears the renderers cache
            </summary>
        </member>
        <member name="P:Gibbo.Library.Classes.BMFontLoader.FontRenderers">
            <summary>
            The available font renderers
            </summary>
        </member>
        <member name="T:Gibbo.Library.BitmapFontRenderer">
            <summary>
            Font Renderer
            </summary>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.#ctor(Gibbo.Library.FontFile,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Instantiates this instance
            </summary>
            <param name="fontFile">The font file</param>
            <param name="fontTexture">The font texture</param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.DrawText(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,System.String)">
            <summary>
            Draws Text
            </summary>
            <param name="spriteBatch">The spritebatch</param>
            <param name="position">The position</param>
            <param name="text">The text to be drawn</param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.DrawText(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,System.String,Microsoft.Xna.Framework.Color)">
            <summary>
            
            </summary>
            <param name="spriteBatch"></param>
            <param name="position"></param>
            <param name="text"></param>
            <param name="color"></param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.DrawText(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,System.String,System.Single)">
            
            <summary>
            Draws Text
            </summary>
            <param name="spriteBatch">The spritebatch</param>
            <param name="position">The position</param>
            <param name="text">The text to be drawn</param>
            <param name="scale">The scale</param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.DrawText(Microsoft.Xna.Framework.Graphics.SpriteBatch,System.Int32,System.Int32,System.String)">
            <summary>
            Draws Text
            </summary>
            <param name="spriteBatch">The spritebatch</param>
            <param name="x">Position X</param>
            <param name="y">Position Y</param>
            <param name="text">The text to be drawn</param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.DrawText(Microsoft.Xna.Framework.Graphics.SpriteBatch,System.Int32,System.Int32,System.String,System.Single,Microsoft.Xna.Framework.Color,System.Int32,Gibbo.Library.TextAlignModes)">
            <summary>
            
            </summary>
            <param name="spriteBatch"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="text"></param>
            <param name="scale"></param>
            <param name="color"></param>
            <param name="lineSpacing"></param>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.MeasureString(System.String,System.Single,System.Int32)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="scale"></param>
            <param name="lineSpacing"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.MeasureString(System.String[],System.Single,System.Int32)">
            <summary>
            Measure all lines resulting in the max size
            </summary>
            <param name="lines"></param>
            <param name="scale"></param>
            <param name="lineSpacing"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.BitmapFontRenderer.MeasureString(System.String,System.Single)">
            <summary>
            Measure a string (width and height)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Gibbo.Library.BitmapFontRenderer.FontFile">
            <summary>
            
            </summary>
            
        </member>
        <member name="P:Gibbo.Library.BitmapFontRenderer.Texture">
            <summary>
            
            </summary>
            
        </member>
        <member name="T:Gibbo.Library.AnimatedSprite">
            <summary>
            Animated Sprite Object
            </summary>
        </member>
        <member name="T:Gibbo.Library.GameObject">
            <summary>
            Game Object
            This class can be used to represent objects in the game. You can attach components to it.
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.#ctor">
            <summary>
            The default constructor of this game object.
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.Initialize">
            <summary>
            Initializes this object.
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.GetComponents">
            <summary>
            Gets the components of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.AddComponent(Gibbo.Library.ObjectComponent)">
            <summary>
            Adds a component to this object.
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.RemoveComponent(Gibbo.Library.ObjectComponent)">
            <summary>
            Remove a component from this object
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.RemoveAllComponents">
            <summary>
            Remove all components from this object
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.SaveComponentValues">
            <summary>
            Save the current state of this object components.
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Updates the logic of this game object.
            Components and children are notified to \.
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws the game object.
            Components and children are notified to draw.
            </summary>
            <param name="gameTime"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.Remove(System.String)">
            <summary>
            Removes the gameobject in the active scene by its name
            </summary>
            <param name="src">object name</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.Remove(Gibbo.Library.GameObject)">
            <summary>
            Removes a game object by it's reference
            </summary>
            <param name="gameObject">The object to remove</param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.Find(System.String,Gibbo.Library.SearchOptions)">
            <summary>
            Searches for the gameobject in the active scene 
            </summary>
            <param name="src">search parameter</param>
            <param name="searchOption">what to look for</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.GetAllGameObjects">
            <summary>
            Gets all gameobjects
            </summary>
            <returns>A list with all the game objects of the current scene</returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.Remove">
            <summary>
            Removes this object from the hierarchy
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseDown(Gibbo.Library.MouseEventButton)">
            <summary>
            Event thrown when there is a mouse down collision
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseClick(Gibbo.Library.MouseEventButton)">
            <summary>
            Event thrown when there is a mouse click collision
            </summary>
            <param name="buttonPressed">The button that was pressed</param>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseMove">
            <summary>
            Event thrown when there is a mouse move collision
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseEnter">
            <summary>
            Event thrown when the mouse enters in collision with the game object
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseUp">
            <summary>
            Event thrown when the mouse is not over the object
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnMouseOut">
            <summary>
            Event thrown when the mouse is not over the object
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnCollisionEnter(Gibbo.Library.GameObject)">
            <summary>
            Event thrown when another object collides with this.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.OnCollisionFree">
            <summary>
            Event thrown in a frame where there is no collision with other objects
            </summary>
        </member>
        <member name="M:Gibbo.Library.GameObject.Save(System.String)">
            <summary>
            Saves the game object
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Gibbo.Library.GameObject.Clone">
            <summary>
            Clone the game object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.Copy">
            <summary>
            Clone de game object 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.ToString">
            <summary>
            To String.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.GameObject.Dispose">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Body">
            <summary>
            The attached body  
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Children">
            <summary>
            The children game objects
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.MouseOver">
            <summary>
            Gets the mouse over state in this object
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Tag">
            <summary>
            Game object tag.
            This can be used to reference the game object in the game.
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Visible">
            <summary>
            Determine if the object is to be drawn in the game.
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Selectable">
            <summary>
            Determine if the object can be selected
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Name">
            <summary>
            The name of the object
            </summary>
        </member>
        <member name="P:Gibbo.Library.GameObject.Transform">
            <summary>
            The object Transformation Matrix.
            </summary>
        </member>
        <member name="M:Gibbo.Library.AnimatedSprite.Initialize">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.AnimatedSprite.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Updates this instance
            </summary>
            <param name="gameTime">The gametime</param>
        </member>
        <member name="M:Gibbo.Library.AnimatedSprite.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws this instance
            </summary>
            <param name="gameTime">The gametime</param>
            <param name="spriteBatch">The spriteBatch</param>
        </member>
        <member name="E:Gibbo.Library.AnimatedSprite.RowCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="E:Gibbo.Library.AnimatedSprite.AnimationCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.PlayMode">
            <summary>
            Determines the animated sprite play mode
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.ResetOnStart">
            <summary>
            Determines if the current row/colum should reset on start
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.Texture">
            <summary>
            The active texture of the animated sprite
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.FrameWidth">
            <summary>
            The active texture frame width
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.FrameHeight">
            <summary>
            The active texture frame width
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.BlendMode">
            <summary>
            The blending mode
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.CurrentRow">
            <summary>
            Automatically calculates the collision boundries based on the texture size
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.CurrentColumn">
            <summary>
            Automatically calculates the collision boundries based on the texture size
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.Delay">
            <summary>
            The delay of each animation step
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.TotalFramesPerRow">
            <summary>
            The total frames available in each texture
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.TotalRows">
            <summary>
            The total rows available in each texture
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.IsPlaying">
            <summary>
            Determines if the current texture is being animated
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.PlayAllRows">
            <summary>
            Determines if animation should proceed to the next row when the current row is finished
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.ImageName">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.Loop">
            <summary>
            Determines if the current texture is being animated
            </summary>
        </member>
        <member name="P:Gibbo.Library.AnimatedSprite.Color">
            <summary>
            The fill color
            </summary>
        </member>
        <member name="T:Gibbo.Library.Audio">
            <summary>
            Class to play Audio
            </summary>
            
        </member>
        <member name="M:Gibbo.Library.Audio.ClearBuffer">
            <summary>
            Clears the Audio Buffer
            </summary>
        </member>
        <member name="M:Gibbo.Library.Audio.Unload">
            <summary>
            Unloads audio wave
            </summary>
        </member>
        <member name="M:Gibbo.Library.Audio.LoadSoundToBuffer(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="filepath"></param>
            <param name="volume"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Audio.PlayFromBuffer(System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="loop"></param>
        </member>
        <member name="M:Gibbo.Library.Audio.PlayAudio(System.String,System.Boolean)">
            <summary>
            Play a .mp3 or .wav audio file
            </summary>
            <param name="filePath">The relative path to the audio file</param>
            <param name="loop">Determine if the sound should loop</param>
        </member>
        <member name="M:Gibbo.Library.Audio.PlayAudio(System.String)">
            <summary>
            Play a .mp3 or .wav audio file
            </summary>
            <param name="filePath">The relative path to the audio file</param>
        </member>
        <member name="M:Gibbo.Library.Audio.CreateInputStream(System.String,System.Single,System.Boolean)">
            <summary>
            Creates a wave stream from a selected file
            </summary>
            <param name="fileName">The file path to the audio file (.mp3 or .wav)</param>
            <param name="volume">The default desired volume</param>
            <param name="addToBuffer">Determines if the audio file is added to the buffer</param>
            <returns></returns>
        </member>
        <member name="T:Gibbo.Library.AudioObject">
            <summary>
            Audio Game Object
            </summary>
        </member>
        <member name="M:Gibbo.Library.AudioObject.Initialize">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.AudioObject.Play">
            <summary>
            Plays the selected audio file
            </summary>
        </member>
        <member name="M:Gibbo.Library.AudioObject.Pause">
            <summary>
            Pauses the selected audio file
            </summary>
        </member>
        <member name="M:Gibbo.Library.AudioObject.Stop">
            <summary>
            Stops the selected audio file
            </summary>
        </member>
        <member name="M:Gibbo.Library.AudioObject.Restart">
            <summary>
            Restarts the selected audio file
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.FilePath">
            <summary>
            The relative path to the audio file
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.Loop">
            <summary>
            Determine if the audio will loop in the end
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.Volume">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.Position">
            <summary>
            The audio position of the current track
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.IsPlaying">
            <summary>
            Determine if the audio is playing
            </summary>
        </member>
        <member name="P:Gibbo.Library.AudioObject.PlayOnStart">
            <summary>
            Determine if the audio will automatically play when a scene is loaded
            </summary>
        </member>
        <member name="T:Gibbo.Library.Camera">
            <summary>
            Game Camera
            </summary>
        </member>
        <member name="M:Gibbo.Library.Camera.#ctor">
            <summary>
            Camera constructor
            </summary>
        </member>
        <member name="M:Gibbo.Library.Camera.CalculateTransform">
            <summary>
            Calculates the transformation matrix of the camera.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Camera.ObjectTransform(Gibbo.Library.GameObject)">
            <summary>
            Calculates the transformation matrix of the camera for a given game object
            </summary>
            <param name="obj">The game object</param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Camera.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Gibbo.Library.Camera.Rotation">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Camera.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Camera.Zoom">
            <summary>
            Camera zoom
            </summary>
            
        </member>
        <member name="P:Gibbo.Library.Camera.TransformMatrix">
            <summary>
            The current Camera.tion matrix.
            </summary>
        </member>
        <member name="P:Gibbo.Library.Camera.BoundingBox">
            <summary>
            The bounding box of the tile
            </summary>
        </member>
        <member name="T:Gibbo.Library.BMFont">
            <summary>
            Bitmap Font Class
            </summary>
        </member>
        <member name="M:Gibbo.Library.BMFont.Initialize">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.BMFont.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws this instance
            </summary>
            <param name="gameTime">The gametime</param>
            <param name="spriteBatch">The spriteBatch</param>
        </member>
        <member name="P:Gibbo.Library.BMFont.AlignMode">
            <summary>
            The alignment mode 
            </summary>
        </member>
        <member name="P:Gibbo.Library.BMFont.Text">
            <summary>
            The text to be displayed
            </summary>
        </member>
        <member name="P:Gibbo.Library.BMFont.FntFilePath">
            <summary>
            The relative fnt file path
            </summary>
        </member>
        <member name="P:Gibbo.Library.BMFont.TextureFilePath">
            <summary>
            The relative texture file path
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Gibbo.Library.BMFont.Origin" -->
        <member name="P:Gibbo.Library.BMFont.LineSpacing">
            <summary>
            The spacing between lines
            </summary>
        </member>
        <member name="P:Gibbo.Library.BMFont.OverlayColor">
            <summary>
            The overlay color
            </summary>
        </member>
        <member name="T:Gibbo.Library.ParticleEmitter">
            <summary>
            The particle emitter class
            </summary>
        </member>
        <member name="M:Gibbo.Library.ParticleEmitter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Gibbo.Library.ParticleEmitter.Initialize">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.ParticleEmitter.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Updates this instance
            </summary>
            <param name="gameTime">The gametime</param>
        </member>
        <member name="M:Gibbo.Library.ParticleEmitter.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws this instance
            </summary>
            <param name="gameTime">The gametime</param>
            <param name="spriteBatch">The spriteBatch</param>
        </member>
        <member name="M:Gibbo.Library.ParticleEmitter.Clear">
            <summary>
            Clears the active particles
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.Burst">
            <summary>
            Determines if the particle emitter should burst or play repeatedly
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.MaxParticles">
            <summary>
            The max amount of particles alive in this emmiter
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.SecondsPerSpawnMin">
            <summary>
            The minimum amount of time to hold before spawning another particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.SecondsPerSpawnMax">
            <summary>
            The maximum amount of time to hold before spawning another particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.LifespanMin">
            <summary>
            The minimum amount of time that a particle is kept alive
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.LifespanMax">
            <summary>
            The maximum amount of time that a particle is kept alive
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialScaleMin">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialScaleMax">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalScaleMin">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalScaleMax">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialSpeedMin">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialSpeedMax">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalSpeedMin">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalSpeedMax">
            <summary>
            The initial scale of a particle (mininal range)
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.SpawnDirection">
            <summary>
            The direction of a particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.SpawnAngleNoise">
            <summary>
            The spawning noise angle of a particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialColor1">
            <summary>
            One possible initial color of a particle
            </summary>    
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.InitialColor2">
            <summary>
            One possible initial color of a particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalColor1">
            <summary>
            One possible final color of a particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.FinalColor2">
            <summary>
            One possible final color of a particle
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.Enabled">
            <summary>
            Determines if the particles are enabled
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.ImageName">
            <summary>
            The relative path to the texture
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.BlendMode">
            <summary>
            The blending mode
            </summary>
        </member>
        <member name="P:Gibbo.Library.ParticleEmitter.RotationStrength">
            <summary>
            The rotation strength of the particles
            </summary>
        </member>
        <member name="T:Gibbo.Library.Path">
            <summary>
            Path Object
            </summary>
        </member>
        <member name="M:Gibbo.Library.Path.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws this instance
            </summary>
            <param name="gameTime"></param>
            <param name="spriteBatch"></param>
        </member>
        <member name="P:Gibbo.Library.Path.Points">
            <summary>
            The points of the path
            </summary>
        </member>
        <member name="T:Gibbo.Library.Tile">
            <summary>
            Tile Structure
            </summary>
        </member>
        <member name="F:Gibbo.Library.Tile.Source">
            <summary>
            The source rectangle of the tile
            </summary>
        </member>
        <member name="M:Gibbo.Library.Tile.DeepCopy">
            <summary>
            Deep Copy 
            </summary>
            <returns>New tile based on this instance</returns>
        </member>
        <member name="T:Gibbo.Library.Tileset">
            <summary>
            Brush Object
            </summary>
        </member>
        <member name="M:Gibbo.Library.Tileset.CollisionZone(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Gets the near area of the matrix where the boundries are colliding
            </summary>
            <param name="boundries">Collision boundry to test</param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.#ctor">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.Tileset.Initialize">
            <summary>
            Initializes this instance
            </summary>
        </member>
        <member name="M:Gibbo.Library.Tileset.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Updates this instance
            </summary>
            <param name="gameTime">The gametime</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.Draw(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
            <summary>
            Draws this instance
            </summary>
            <param name="gameTime">The gametime</param>
            <param name="spriteBatch">The spriteBatch</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.ResizeTileset(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="newWidth"></param>
            <param name="newHeight"></param>
        </member>
        <member name="M:Gibbo.Library.Tileset.TileWorldPos(System.Int32,System.Int32)">
            <summary>
            Gets the tile world position based on the matrix position
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.TileMatrixPos(System.Single,System.Single)">
            <summary>
            Gets the matrix position based on the world position
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.PlaceTiles(Gibbo.Library.Tile[0:,0:],Microsoft.Xna.Framework.Vector2)">
            <summary>
            Places a matrix of tiles
            </summary>
            <param name="newTiles">The tiles to place</param>
            <param name="startingPosition">The starting position (world position)</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.PlaceTiles(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Places tiles based on the source.
            This method automatically cuts the source overflow by dividing it in singular tiles.
            </summary>
            <param name="source">The area of the image that you want to use</param>
            <param name="worldPosition">The world position</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.PlaceTiles(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Places tiles based on the source and area.
            This method automatically cuts the source overflow by dividing it in singular tiles.
            </summary>
            <param name="source">The area of the image that you want to use</param>
            <param name="area">The area of the map you want to use</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.PlaceTile(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Places a tile at a desired position
            </summary>
            <param name="sourcePosition">The position of the image that you want to use</param>
            <param name="worldPosition">The world position</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.ValidPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Validates position
            </summary>
            <param name="position">Matrix position</param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.WorldAreaToMatrix(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            
            </summary>
            <param name="area"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.RemoveTiles(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Removes tiles from a selected area (world position)
            </summary>
            <param name="area">The area (world position) you want to have tiles removed</param>
            <returns>The removed tiles</returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.AddColumn(System.Int32)">
            <summary>
            Adds a column
            </summary>
            <param name="pointX">The column position (world coordinates)</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.AddRow(System.Int32)">
            <summary>
            Adds a row
            </summary>
            <param name="pointY">The row position (world coordinates)</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.RemoveColumn(System.Int32)">
            <summary>
            Removes a column
            </summary>
            <param name="pointX">The column position (world coordinates)</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.RemoveRow(System.Int32)">
            <summary>
            Removes a row
            </summary>
            <param name="pointY">The row position (world coordinates)</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.GrabTiles(Microsoft.Xna.Framework.Rectangle,System.Boolean)">
            <summary>
            Grabs all the tiles in the selected area
            </summary>
            <param name="area">The area to grab the tiles, must be multiple of the tile width and height.</param>
            <param name="clone">Determines if the result should use cloned tiles</param>
            <returns>The matrix of the tiles that were found. This result may contain null positions in case you select areas that aren't fully filled.</returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.ShiftLeft(System.Int32)">
            <summary>
            Shifts left (amount) positions
            </summary>
            <param name="amount">The amount of positions to shift</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.ShiftRight(System.Int32)">
            <summary>
            Shifts right (amount) positions
            </summary>
            <param name="amount">The amount of positions to shift</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.ShiftUp(System.Int32)">
            <summary>
            Shifts up (amount) positions
            </summary>
            <param name="amount">The amount of positions to shift</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.ShiftDown(System.Int32)">
            <summary>
            Shifts down (amount) positions
            </summary>
            <param name="amount">The amount of positions to shift</param>
        </member>
        <member name="M:Gibbo.Library.Tileset.DeepCopy">
            <summary>
            Deep Copy
            </summary>
            <returns>A new array of the tiles in this tileset</returns>
        </member>
        <member name="M:Gibbo.Library.Tileset.MeasureDimension">
            <summary>
            Measures the dimension of this object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Gibbo.Library.Tileset.Color">
            <summary>
            The fill color
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.UseRenderTarget">
            <summary>
            Determine if in game mode it should use a render target
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.Tiles">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.TileWidth">
            <summary>
            The tile size (width)
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.TileHeight">
            <summary>
            The tile size (height)
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.ImageName">
            <summary>
            The relative path to the image
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.Texture">
            <summary>
            The active texture
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.Width">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.Height">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Tileset.VisibleTiles">
            <summary>
            
            </summary>
        </member>
        <member name="T:Gibbo.Library.GameObjectCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:Gibbo.Library.Physics">
            <summary>
            
            </summary>
        </member>
        <member name="P:Gibbo.Library.Physics.World">
            <summary>
            The active physics world
            </summary>
        </member>
        <member name="M:FarseerPhysics.DebugView.PrimitiveBatch.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            the constructor creates a new PrimitiveBatch and sets up all of the internals
            that PrimitiveBatch will need.
            </summary>
            <param name="graphicsDevice">The graphics device.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.PrimitiveBatch.Begin(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Begin is called to tell the PrimitiveBatch what kind of primitives will be
            drawn, and to prepare the graphics card to render those primitives.
            </summary>
            <param name="projection">The projection.</param>
            <param name="view">The view.</param>
        </member>
        <member name="M:FarseerPhysics.DebugView.PrimitiveBatch.End">
            <summary>
            End is called once all the primitives have been drawn using AddVertex.
            it will call Flush to actually submit the draw call to the graphics card, and
            then tell the basic effect to end.
            </summary>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.ChangePosition(System.Int32,System.Int32)">
            <summary>
            Used for changing the X and Y position of the RotatedRectangle
            </summary>
            <param name="theXPositionAdjustment"></param>
            <param name="theYPositionAdjustment"></param>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.Intersects(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            This intersects method can be used to check a standard XNA framework Rectangle
            object and see if it collides with a Rotated Rectangle object
            </summary>
            <param name="theRectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.Intersects(Gibbo.Library.RotatedRectangle)">
            <summary>
            Check to see if two Rotated Rectangls have collided
            </summary>
            <param name="theRectangle"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.IsAxisCollision(Gibbo.Library.RotatedRectangle,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Determines if a collision has occurred on an Axis of one of the
            planes parallel to the Rectangle
            </summary>
            <param name="theRectangle"></param>
            <param name="aAxis"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.GenerateScalar(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Generates a scalar value that can be used to compare where corners of 
            a rectangle have been projected onto a particular axis. 
            </summary>
            <param name="theRectangleCorner"></param>
            <param name="theAxis"></param>
            <returns></returns>
        </member>
        <member name="M:Gibbo.Library.RotatedRectangle.RotatePoint(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Rotate a point from a given location and adjust using the Origin we
            are rotating around
            </summary>
            <param name="thePoint"></param>
            <param name="theOrigin"></param>
            <param name="theRotation"></param>
            <returns></returns>
        </member>
        <member name="T:Gibbo.Library.ContentBrowserEditor">
            <summary>
            
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ContactFeature">
            <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexA">
            <summary>
            Feature index on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.IndexB">
            <summary>
            Feature index on ShapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeA">
            <summary>
            The feature type on ShapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactFeature.TypeB">
            <summary>
            The feature type on ShapeB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ContactID">
            <summary>
            Contact ids to facilitate warm starting.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Features">
            <summary>
            The features that intersect to form the contact point
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ContactID.Key">
            <summary>
            Used to quickly compare contact ids.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ManifoldPoint">
            <summary>
            A manifold point is a contact point belonging to a contact
            manifold. It holds details related to the geometry and dynamics
            of the contact points.
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleB
            -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
            -SeparationFunction.FaceB: the clip point of polygonA
            This structure is stored across time steps, so we keep it small.
            Note: the impulses are used for internal caching and may not
            provide reliable contact forces, especially for high speed collisions.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.Id">
            <summary>
            Uniquely identifies a contact point between two Shapes
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.NormalImpulse">
            <summary>
            The non-penetration impulse
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.ManifoldPoint.TangentImpulse">
            <summary>
            The friction impulse
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Manifold">
            <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - Clip point versus plane with radius
            - Point versus point with radius (circles)
            The local point usage depends on the manifold type:
            - ShapeType.Circles: the local center of circleA
            - SeparationFunction.FaceA: the center of faceA
            - SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            - ShapeType.Circles: not used
            - SeparationFunction.FaceA: the normal on polygonA
            - SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalNormal">
            <summary>
            Not use for Type.SeparationFunction.Points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.PointCount">
            <summary>
            The number of manifold points
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Manifold.Points">
            <summary>
            The points of contact
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.PointState">
            <summary>
            This is used for determining the state of contact points.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Null">
            <summary>
            Point does not exist
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Add">
            <summary>
            Point was added in the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Persist">
            <summary>
            Point persisted across the update
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.PointState.Remove">
            <summary>
            Point was removed in the update
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ClipVertex">
            <summary>
            Used for computing contact manifolds.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastInput">
            <summary>
            Ray-cast input data.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.RayCastInput.MaxFraction">
            <summary>
            The ray extends from p1 to p1 + maxFraction * (p2 - p1).
            If you supply a max fraction of 1, the ray extends from p1 to p2.
            A max fraction of 0.5 makes the ray go from p1 and half way to p2.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.RayCastInput.Point1">
            <summary>
            The starting point of the ray.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.RayCastInput.Point2">
            <summary>
            The ending point of the ray.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.RayCastOutput">
            <summary>
            Ray-cast output data. 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.RayCastOutput.Fraction">
            <summary>
            The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from RayCastInput.
            Contains the actual fraction of the ray where it has the intersection point.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.RayCastOutput.Normal">
            <summary>
            The normal of the face of the shape the ray has hit.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.AABB">
            <summary>
            An axis aligned bounding box.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.LowerBound">
            <summary>
            The lower vertex
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.AABB.UpperBound">
            <summary>
            The upper vertex
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.IsValid">
            <summary>
            Verify that the bounds are sorted. And the bounds are valid numbers (not NaN).
            </summary>
            <returns>
            	<c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine an AABB into this one.
            </summary>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@,FarseerPhysics.Collision.AABB@)">
            <summary>
            Combine two AABBs into this one.
            </summary>
            <param name="aabb1">The aabb1.</param>
            <param name="aabb2">The aabb2.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(FarseerPhysics.Collision.AABB@)">
            <summary>
            Does this aabb contain the provided AABB.
            </summary>
            <param name="aabb">The aabb.</param>
            <returns>
            	<c>true</c> if it contains the specified aabb; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.Contains(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Determines whether the AAABB contains the specified point.
            </summary>
            <param name="point">The point.</param>
            <returns>
            	<c>true</c> if it contains the specified point; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.TestOverlap(FarseerPhysics.Collision.AABB@,FarseerPhysics.Collision.AABB@)">
            <summary>
            Test if the two AABBs overlap.
            </summary>
            <param name="a">The first AABB.</param>
            <param name="b">The second AABB.</param>
            <returns>True if they are overlapping.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.AABB.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,System.Boolean)">
            <summary>
            Raycast against this AABB using the specificed points and maxfraction (found in input)
            </summary>
            <param name="output">The results of the raycast.</param>
            <param name="input">The parameters for the raycast.</param>
            <returns>True if the ray intersects the AABB</returns>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Center">
            <summary>
            Get the center of the AABB.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Extents">
            <summary>
            Get the extents of the AABB (half-widths).
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Perimeter">
            <summary>
            Get the perimeter length
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Vertices">
            <summary>
            Gets the vertices of the AABB.
            </summary>
            <value>The corners of the AABB</value>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Q1">
            <summary>
            First quadrant
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Q2">
            <summary>
            Second quadrant
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Q3">
            <summary>
            Third quadrant
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.AABB.Q4">
            <summary>
            Forth quadrant
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.TempPolygon">
            <summary>
            This holds polygon B expressed in frame A.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.EPAxis">
            <summary>
            This structure is used to keep track of the best separating axis.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.ReferenceFace">
            <summary>
            Reference face used for clipping
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Collision">
            <summary>
            Collision methods
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.TestOverlap(FarseerPhysics.Collision.Shapes.Shape,System.Int32,FarseerPhysics.Collision.Shapes.Shape,System.Int32,FarseerPhysics.Common.Transform@,FarseerPhysics.Common.Transform@)">
            <summary>
            Test overlap between the two shapes.
            </summary>
            <param name="shapeA">The first shape.</param>
            <param name="indexA">The index for the first shape.</param>
            <param name="shapeB">The second shape.</param>
            <param name="indexB">The index for the second shape.</param>
            <param name="xfA">The transform for the first shape.</param>
            <param name="xfB">The transform for the seconds shape.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideCircles(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between two circles.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="xfA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="xfB">The transform of B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollidePolygons(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute the collision manifold between two polygons.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polyA">The poly A.</param>
            <param name="transformA">The transform A.</param>
            <param name="polyB">The poly B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Compute contact points for edge versus circle.
            This accounts for edge connectivity.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="transformA">The transform A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Collides and edge and a polygon, taking into account edge adjacency.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="xfA">The xf A.</param>
            <param name="polygonB">The polygon B.</param>
            <param name="xfB">The xf B.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.ClipSegmentToLine(FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32)">
            <summary>
            Clipping for contact manifolds.
            </summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.EdgeSeparation(FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,System.Int32,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Find the separation between poly1 and poly2 for a give edge normal on poly1.
            </summary>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="edge1">The edge1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Collision.FindMaxSeparation(System.Int32@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
            <summary>
            Find the max separation between poly1 and poly2 using edge normals from poly1.
            </summary>
            <param name="edgeIndex">Index of the edge.</param>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceProxy">
            <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.Set(FarseerPhysics.Collision.Shapes.Shape,System.Int32)">
            <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
            <param name="shape">The shape.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupport(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex index in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupportVertex(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Collision.SimplexCache">
            <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.Count">
            <summary>
            Length or area
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexA">
            <summary>
            Vertices on shape A
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexCache.IndexB">
            <summary>
            Vertices on shape B
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceInput">
            <summary>
            Input for Distance.ComputeDistance().
            You have to option to use the shape radii in the computation. 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DistanceOutput">
            <summary>
            Output for Distance.ComputeDistance().
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.Iterations">
            <summary>
            Number of GJK iterations used
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointA">
            <summary>
            Closest point on shapeA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.DistanceOutput.PointB">
            <summary>
            Closest point on shapeB
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.A">
            <summary>
            Barycentric coordinate for closest point 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexA">
            <summary>
            wA index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexB">
            <summary>
            wB index
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.W">
            <summary>
            wB - wA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WA">
            <summary>
            Support point in proxyA
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.SimplexVertex.WB">
            <summary>
            Support point in proxyB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Distance">
            <summary>
            The GilbertJohnsonKeerthi distance algorithm that provides the distance between shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Distance.GJKCalls">
            <summary>
            The number of calls made to the ComputeDistance() function.
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Distance.GJKIters">
            <summary>
            The number of iterations that was made on the last call to ComputeDistance().
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Distance.GJKMaxIters">
            <summary>
            The maximum numer of iterations ever mae with calls to the CompteDistance() funtion.
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.TreeNode`1">
            <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.TreeNode`1.AABB">
            <summary>
            Enlarged AABB
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTree`1">
             <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.#ctor">
            <summary>
            Constructing the tree initializes the node pool.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.AddProxy(FarseerPhysics.Collision.AABB@,`0)">
            <summary>
            Create a proxy in the tree as a leaf node. We return the index
            of the node instead of a pointer so that we can grow
            the node pool.        
            /// </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns>Index of the created proxy</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.MoveProxy(System.Int32,FarseerPhysics.Collision.AABB@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetUserData(System.Int32)">
            <summary>
            Get proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns>the proxy user data or 0 if the id is invalid.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAABB">The fat AABB.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a Shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.Balance(System.Int32)">
            <summary>
            Perform a left or right rotation if node A is imbalanced.
            </summary>
            <param name="iA"></param>
            <returns>the new root index.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.ComputeHeight(System.Int32)">
            <summary>
            Compute the height of a sub-tree.
            </summary>
            <param name="nodeId">The node id to use as parent.</param>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.ComputeHeight">
            <summary>
            Compute the height of the entire tree.
            </summary>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.Validate">
            <summary>
            Validate this tree. For testing.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.RebuildBottomUp">
            <summary>
            Build an optimal tree. Very expensive. For testing.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTree`1.ShiftOrigin(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Shift the origin of the nodes
            </summary>
            <param name="newOrigin">The displacement to use.</param>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTree`1.Height">
            <summary>
            Compute the height of the binary tree in O(N) time. Should not be called often.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTree`1.AreaRatio">
            <summary>
            Get the ratio of the sum of the node areas to the root area.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTree`1.MaxBalance">
            <summary>
            Get the maximum balance of an node in the tree. The balance is the difference
            in height of the two children of a node.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.DynamicTreeBroadPhase">
            <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.#ctor">
            <summary>
            Constructs a new broad phase based on the dynamic tree implementation
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.AddProxy(FarseerPhysics.Dynamics.FixtureProxy@)">
            <summary>
            Create a proxy with an initial AABB. Pairs are not reported until
            UpdatePairs is called.
            </summary>
            <param name="proxy">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. It is up to the client to remove any pairs.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.QueryCallback(System.Int32)">
            <summary>
            This is called from DynamicTree.Query when we are gathering pairs.
            </summary>
            <param name="proxyId"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
            <summary>
            Get the AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetProxy(System.Int32)">
            <summary>
            Get user data from a proxy. Returns null if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.UpdatePairs(FarseerPhysics.Dynamics.BroadphaseDelegate)">
            <summary>
            Update the pairs. This results in pair callbacks. This can only add pairs.
            </summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.ProxyCount">
            <summary>
            Get the number of proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.TreeQuality">
            <summary>
            Get the tree quality based on the area of the tree.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.TreeBalance">
            <summary>
            Gets the balance of the tree.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.TreeHeight">
            <summary>
            Gets the height of the tree.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.ChainShape">
            <summary>
            A chain shape is a free form sequence of line segments.
            The chain has two-sided collision, so you can use inside and outside collision.
            Therefore, you may use any winding order.
            Connectivity information is used to create smooth collisions.
            WARNING: The chain will not collide properly if there are self-intersections.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.Shape">
            <summary>
            A shape is used for collision detection. You can create a shape however you like.
            Shapes used for simulation in World are created automatically when a Fixture
            is created. Shapes may encapsulate a one or more child shapes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.Shape.MassData">
            <summary>
            Contains the properties of the shape such as:
            - Area of the shape
            - Centroid
            - Inertia
            - Mass
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.Clone">
            <summary>
            Clone the concrete shape
            </summary>
            <returns>A clone of the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape.
            Note: This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">A point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.CompareTo(FarseerPhysics.Collision.Shapes.Shape)">
            <summary>
            Compare this shape to another shape based on type and properties.
            </summary>
            <param name="shape">The other shape</param>
            <returns>True if the two shapes are the same.</returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeSubmergedArea(Microsoft.Xna.Framework.Vector2@,System.Single,FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Used for the buoyancy controller
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ShapeType">
            <summary>
            Get the type of this shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.ChildCount">
            <summary>
            Get the number of child primitives.
            </summary>
            <value></value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.Density">
            <summary>
            Gets or sets the density.
            Changing the density causes a recalculation of shape properties.
            </summary>
            <value>The density.</value>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.Shape.Radius">
            <summary>
            Radius of the Shape
            Changing the radius causes a recalculation of shape properties.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.ChainShape.Vertices">
            <summary>
            The vertices. These are not owned/freed by the chain Shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.ChainShape.#ctor">
            <summary>
            Constructor for ChainShape. By default have 0 in density.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.ChainShape.#ctor(FarseerPhysics.Common.Vertices,System.Boolean)">
            <summary>
            Create a new chainshape from the vertices.
            </summary>
            <param name="vertices">The vertices to use. Must contain 2 or more vertices.</param>
            <param name="createLoop">Set to true to create a closed loop. It connects the first vertice to the last, and automatically adjusts connectivity to create smooth collisions along the chain.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.ChainShape.GetChildEdge(FarseerPhysics.Collision.Shapes.EdgeShape,System.Int32)">
            <summary>
            This method has been optimized to reduce garbage.
            </summary>
            <param name="edge">The cached edge to set properties on.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.ChainShape.GetChildEdge(System.Int32)">
            <summary>
            Get a child edge.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.ChainShape.CompareTo(FarseerPhysics.Collision.Shapes.ChainShape)">
            <summary>
            Compare the chain to another chain
            </summary>
            <param name="shape">The other chain</param>
            <returns>True if the two chain shapes are the same</returns>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.ChainShape.PrevVertex">
            <summary>
            Establish connectivity to a vertex that precedes the first vertex.
            Don't call this for loops.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.ChainShape.NextVertex">
            <summary>
            Establish connectivity to a vertex that follows the last vertex.
            Don't call this for loops.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.CircleShape">
            <summary>
            A circle shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.#ctor(System.Single,System.Single)">
            <summary>
            Create a new circle with the desired radius and density.
            </summary>
            <param name="radius">The radius of the circle.</param>
            <param name="density">The density of the circle.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.CompareTo(FarseerPhysics.Collision.Shapes.CircleShape)">
            <summary>
            Compare the circle to another circle
            </summary>
            <param name="shape">The other circle</param>
            <returns>True if the two circles are the same size and have the same position</returns>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.CircleShape.Position">
            <summary>
            Get or set the position of the circle
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.EdgeShape">
            <summary>
            A line segment (edge) shape. These can be connected in chains or loops
            to other edge shapes.
            The connectivity information is used to ensure correct contact normals.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex1">
            <summary>
            Edge start vertex
            </summary>
        </member>
        <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex2">
            <summary>
            Edge end vertex
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Create a new EdgeShape with the specified start and end.
            </summary>
            <param name="start">The start of the edge.</param>
            <param name="end">The end of the edge.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as an isolated edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.HasVertex0">
            <summary>
            Is true if the edge is connected to an adjacent vertex before vertex 1.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.HasVertex3">
            <summary>
            Is true if the edge is connected to an adjacent vertex after vertex2.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex0">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex3">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex1">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex2">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.PolygonShape">
            <summary>
            Represents a simple non-selfintersecting convex polygon.
            Create a convex hull from the given array of points.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.#ctor(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Collision.Shapes.PolygonShape"/> class.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.#ctor(System.Single)">
            <summary>
            Create a new PolygonShape with the specified density.
            </summary>
            <param name="density">The density.</param>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.PolygonShape.Vertices">
            <summary>
            Create a convex hull from the given array of local points.
            The number of vertices must be in the range [3, Settings.MaxPolygonVertices].
            Warning: the points may be re-ordered, even if they form a convex polygon
            Warning: collinear points are handled but not removed. Collinear points may lead to poor stacking behavior.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.Shapes.MassData">
            <summary>
            This holds the mass data computed for a shape.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.MassData.op_Equality(FarseerPhysics.Collision.Shapes.MassData,FarseerPhysics.Collision.Shapes.MassData)">
            <summary>
            The equal operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Collision.Shapes.MassData.op_Inequality(FarseerPhysics.Collision.Shapes.MassData,FarseerPhysics.Collision.Shapes.MassData)">
            <summary>
            The not equal operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.MassData.Area">
            <summary>
            The area of the shape
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.MassData.Centroid">
            <summary>
            The position of the shape's centroid relative to the shape's origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.MassData.Inertia">
            <summary>
            The rotational inertia of the shape about the local origin.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Collision.Shapes.MassData.Mass">
            <summary>
            The mass of the shape, usually in kilograms.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Collision.TOIInput">
            <summary>
            Input parameters for CalculateTimeOfImpact
            </summary>
        </member>
        <member name="M:FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(FarseerPhysics.Collision.TOIOutput@,FarseerPhysics.Collision.TOIInput)">
            <summary>
            Compute the upper bound on time before two shapes penetrate. Time is represented as
            a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
            non-tunneling collision. If you change the time interval, you should call this function
            again.
            Note: use Distance() to compute the contact point and normal at the time of impact.
            </summary>
            <param name="output">The output.</param>
            <param name="input">The input.</param>
        </member>
        <member name="T:FarseerPhysics.Common.ConvexHull.ChainHull">
            <summary>
            Andrew's Monotone Chain Convex Hull algorithm.
            Used to get the convex hull of a point cloud.
            
            Source: http://www.softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.ChainHull.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Returns the convex hull from the given vertices..
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.ConvexHull.GiftWrap">
            <summary>
            Giftwrap convex hull algorithm.
            O(nh) time complexity, where n is the number of points and h is the number of points on the convex hull.
            
            See http://en.wikipedia.org/wiki/Gift_wrapping_algorithm for more details.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.GiftWrap.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Returns the convex hull from the given vertices.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="T:FarseerPhysics.Common.ConvexHull.Melkman">
            <summary>
            Creates a convex hull.
            Note:
            1. Vertices must be of a simple polygon, i.e. edges do not overlap.
            2. Melkman does not work on point clouds
            </summary>
            <remarks>
            Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
            Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            </remarks>
        </member>
        <member name="M:FarseerPhysics.Common.ConvexHull.Melkman.GetConvexHull(FarseerPhysics.Common.Vertices)">
            <summary>
            Returns a convex hull from the given vertices.
            </summary>
            <returns>A convex hull in counter clockwise winding order.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            
            Properties:
            - Tries to decompose using polygons instead of triangles.
            - Tends to produce optimal results with low processing time.
            - Running time is O(nr), n = number of vertices, r = reflex vertices.
            - Does not support holes.
            
            For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.CDTDecomposer">
            <summary>
            2D constrained Delaunay triangulation algorithm.
            Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
            
            Properties:
            - Creates triangles with a large interior angle.
            - Supports holes
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n^2), n = number of vertices.
            - Does not care about winding order.
            
            Source: http://code.google.com/p/poly2tri/
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDTDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            Flags to determine if an edge is a Delauney edge 
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            Flags to determine if an edge is a Constrained edge 
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Points">
            Has this triangle been marked as an interior triangle? 
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighbor(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Update neighbor pointers
            </summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighbor(FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Exhaustive search to update neighbor pointers
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Clear">
            Clears all references to all other triangles and points
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.OppositePoint(FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Legalize(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Legalize triangle by rotating clockwise around oPoint
            </summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighborEdges">
            <summary>
            Finalize edge marking
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkConstrainedEdge(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Mark edge as constrained
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIndex(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
            </summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront">
            @author Thomas hlen (thahlen@gmail.com)
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
            MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                 Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.LocateNode(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            We use a balancing tree to locate a node smaller or equal to given key value
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.LocatePoint(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            This implementation will use simple node traversal algorithm to find a point on the front
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Triangulate(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Triangulate simple polygon with holes
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Sweep(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Start sweeping the Y-sorted point set from bottom to top
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FinalizationConvexHull(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull 
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            We will traverse the entire advancing front and fill it to form a convex hull.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.PointEvent(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Find closes node to the left of the new point and
            create a new triangle. If needed new holes and basins
            will be filled to.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NewFrontTriangle(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Creates a new front triangle and legalize it
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NextFlipPoint(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            When we need to traverse from one triangle to the next we need 
            the point in current triangle that is the opposite point to the next
            triangle. 
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NextFlipTriangle(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Orientation,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            After a flip we have two triangles and know that only one will still be
            intersecting the edge. So decide which to contiune with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)" -->
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillAdvancingFront(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Fills holes in the Advancing Front
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillBasin(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Fills a basin that has formed on the Advancing Front to the right
            of given node.
            First we decide a left,bottom and right node that forms the 
            boundaries of the basin. Then we do a reqursive fill.
            </summary>
            <param name="tcx"></param>
            <param name="node">starting node, this or next node will be left node</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillBasinReq(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Recursive algorithm to fill a Basin with triangles
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.HoleAngle(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            ???
            </summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.BasinAngle(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            The basin angle is decided against the horizontal line [1,0]
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Fill(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Adds a triangle to the advancing front to fill a hole.
            </summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Legalize(FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Returns true if triangle was legalized
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.RotateTrianglePair(FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Rotates a triangle pair one vertex CW
                  n2                    n2
             P +-----+             P +-----+
               | t  /|               |\  t |  
               |   / |               | \   |
             n1|  /  |n3           n1|  \  |n3
               | /   |    after CW   |   \ |
               |/ oT |               | oT \|
               +-----+ oP            +-----+
                  n4                    n4
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepConstraint.#ctor(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Give two points in any order. Will always be ordered so
            that q.y > p.y and q.x > p.x if same y value 
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext">
             
             @author Thomas hln, thahlen@gmail.com
            
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext.MapTriangleToNodes(FarseerPhysics.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Try to map a node to all sides of this triangle that don't have 
            a neighbor.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.#ctor(System.Collections.Generic.IList{FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.PrepareTriangulation(FarseerPhysics.Common.Decomposition.CDT.TriangulationContext)">
            <summary>
            Creates constraints and populates the context with points
            </summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.AddHole(FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon)">
            <summary>
            Add a hole to the polygon.
            </summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.InsertPointAfter(FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint,FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Inserts newPoint after point.
            </summary>
            <param name="point">The point to insert after in the polygon</param>
            <param name="newPoint">The point to insert into the polygon</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Inserts list (after last point in polygon?)
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.AddPoint(FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Adds a point after the last in the polygon.
            </summary>
            <param name="p">The point to add</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Polygon.Polygon.RemovePoint(FarseerPhysics.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Removes a point from the polygon.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint},System.Collections.Generic.IEnumerable{FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint})">
            
            @param points - A list of all points in PointSet
            @param constraints - Pairs of two points defining a constraint, all points <b>must</b> be part of given PointSet!
        </member>
        <!-- Badly formed XML comment ignored for member "M:FarseerPhysics.Common.Decomposition.CDT.Sets.ConstrainedPointSet.isValid" -->
        <member name="T:FarseerPhysics.Common.Decomposition.CDT.TriangulationUtil">
            @author Thomas hln, thahlen@gmail.com
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.TriangulationUtil.SmartIncircle(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
              Requirements:
            1. a,b and c form a triangle.
            2. a and d is know to be on opposite side of bc
            <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
               Facts:
             d has to be in area B to have a chance to be inside the circle formed by a,b and c
             d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
             This preknowledge gives us a way to optimize the incircle test
            </summary>
            <param name="pa">triangle point, opposite d</param>
            <param name="pb">triangle point</param>
            <param name="pc">triangle point</param>
            <param name="pd">point opposite a</param>
            <returns>true if d is inside circle, false if on circle edge</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.CDT.TriangulationUtil.Orient2d(FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint,FarseerPhysics.Common.Decomposition.CDT.TriangulationPoint)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                         =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer">
            <summary>
            Convex decomposition algorithm using ear clipping
            
            Properties:
            - Only works on simple polygons.
            - Does not support holes.
            - Running time is O(n^2), n = number of vertices.
            
            Source: http://www.ewjordan.com/earClip/
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            Each resulting polygon will have no more than Settings.MaxPolygonVertices vertices.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(FarseerPhysics.Common.Vertices,System.Single)">
             <summary>
             Triangulates a polygon using simple ear-clipping algorithm. Returns
             size of Triangle array unless the polygon can't be triangulated.
             This should only happen if the polygon self-intersects,
             though it will not _always_ return null for a bad polygon - it is the
             caller's responsibility to check for self-intersection, and if it
             doesn't, it should at least check that the return value is non-null
             before using. You're warned!
            
             Triangles may be degenerate, especially if you have identical points
             in the input to the algorithm.  Check this before you use them.
            
             This is totally unoptimized, so for large polygons it should not be part
             of the simulation loop.
             </summary>
             <remarks>
             Only works on simple polygons.
             </remarks>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@,System.Single)">
            <summary>
            Finds and fixes "pinch points," points where two polygon
            vertices are at the same point.
            
            If a pinch point is found, pin is broken up into poutA and poutB
            and true is returned; otherwise, returns false.
            
            Mostly for internal use.
            
            O(N^2) time, which sucks...
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <param name="tolerance"></param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
            <summary>
            Fix for obnoxious behavior for the % operator for negative numbers...
            </summary>
            <param name="x">The x.</param>
            <param name="modulus">The modulus.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
            <summary>
            Checks if vertex i is the tip of an ear in polygon defined by xv[] and  yv[].
            </summary>
            <param name="i">The i.</param>
            <param name="xv">The xv.</param>
            <param name="yv">The yv.</param>
            <param name="xvLength">Length of the xv.</param>
            <remarks>
            Assumes clockwise orientation of polygon.
            </remarks>
            <returns>
            	<c>true</c> if the specified i is ear; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.NextIndex(System.Int32)">
            <summary>
            Gets the next index. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.NextVertex(System.Int32)">
            <summary>
            Gets the next vertex. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PreviousVertex(System.Int32)">
            <summary>
            Gets the previous vertex. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetSignedArea">
            <summary>
            Gets the signed area.
            If the area is less than 0, it indicates that the polygon is clockwise winded.
            </summary>
            <returns>The signed area</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetArea">
            <summary>
            Gets the area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetCentroid">
            <summary>
            Gets the centroid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.GetAABB">
            <summary>
            Returns an AABB that fully contains this polygon.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="value">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Rotate(System.Single)">
            <summary>
            Rotate the vertices with the defined value in radians.
            
            Warning: Using this method on an active set of vertices of a Body,
            will cause problems with collisions. Use Body.Rotation instead.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsConvex">
            <summary>
            Determines whether the polygon is convex.
            O(n^2) running time.
            
            Assumptions:
            - The polygon is in counter clockwise order
            - The polygon has no overlapping edges
            </summary>
            <returns>
            	<c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsCounterClockWise">
            <summary>
            Indicates if the vertices are in counter clockwise order.
            Warning: If the area of the polygon is 0, it is unable to determine the winding.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ForceCounterClockWise">
            <summary>
            Forces the vertices to be counter clock wise order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.IsSimple">
            <summary>
            Checks if the vertices forms an simple polygon by checking for edge crossings.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.CheckPolygon">
             <summary>
             Checks if the polygon is valid for use in the engine.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.
             
             From Eric Jordan's convex decomposition library
             </summary>
             <returns>PolygonError.NoError if there were no error.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.ProjectToAxis(Microsoft.Xna.Framework.Vector2@,System.Single@,System.Single@)">
            <summary>
            Projects to axis.
            </summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygon(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Winding number test for a point in a polygon.
            </summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param>
            <returns>-1 if the winding number is zero and the point is outside
            the polygon, 1 if the point is inside the polygon, and 0 if the point
            is on the polygons edge.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.PointInPolygonAngle(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Vertices.Transform(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Transforms the polygon using the defined matrix.
            </summary>
            <param name="transform">The matrix to use as transformation.</param>
        </member>
        <member name="P:FarseerPhysics.Common.Vertices.Holes">
            <summary>
            You can add holes to this collection.
            It will get respected by some of the triangulation algoithms, but otherwise not used.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer">
            <summary>
            Convex decomposition algorithm created by unknown
            
            Properties:
            - No support for holes
            - Very fast
            - Only works on simple polygons
            - Only works on counter clockwise polygons
            
            More information: http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
            <summary>
            Decompose the polygon into triangles.
            
            Properties:
            - Only works on counter clockwise polygons
            
            </summary>
            <param name="vertices">The list of points describing the polygon</param>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Check if the point P is inside the triangle defined by
            the points A, B, C
            </summary>
            <param name="a">The A point.</param>
            <param name="b">The B point.</param>
            <param name="c">The C point.</param>
            <param name="p">The point to be tested.</param>
            <returns>True if the point is inside the triangle</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.Snip(FarseerPhysics.Common.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Cut a the contour and add a triangle into V to describe the 
            location of the cut
            </summary>
            <param name="contour">The list of points defining the polygon</param>
            <param name="u">The index of the first point</param>
            <param name="v">The index of the second point</param>
            <param name="w">The index of the third point</param>
            <param name="n">The number of elements in the array.</param>
            <param name="V">The array to populate with indicies of triangles.</param>
            <returns>True if a triangle was found</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Decomposition.SeidelDecomposer">
            <summary>
            Convex decomposition algorithm created by Raimund Seidel
            
            Properties:
            - Decompose the polygon into trapezoids, then triangulate.
            - To use the trapezoid data, use ConvexPartitionTrapezoid()
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n log n), n = number of vertices.
            - Running time is almost linear for most simple polygons.
            - Does not care about winding order. 
            
            For more information, see Raimund Seidel's paper "A simple and fast incremental randomized
            algorithm for computing trapezoidal decompositions and for triangulating polygons"
            
            See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                      "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
            
            Original code from the Poly2Tri project by Mason Green.
            http://code.google.com/p/poly2tri/source/browse?repo=archive#hg/scala/src/org/poly2tri/seidel
            
            This implementation is from Dec 14, 2010
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygons.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of triangles</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartitionTrapezoid(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygons.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of trapezoids</returns>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.TriangulationAlgorithm.Earclip">
            <summary>
            Convex decomposition algorithm using ear clipping
            
            Properties:
            - Only works on simple polygons.
            - Does not support holes.
            - Running time is O(n^2), n = number of vertices.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.TriangulationAlgorithm.Bayazit">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            
            Properties:
            - Tries to decompose using polygons instead of triangles.
            - Tends to produce optimal results with low processing time.
            - Running time is O(nr), n = number of vertices, r = reflex vertices.
            - Does not support holes.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.TriangulationAlgorithm.Flipcode">
            <summary>
            Convex decomposition algorithm created by unknown
            
            Properties:
            - No support for holes
            - Very fast
            - Only works on simple polygons
            - Only works on counter clockwise polygons
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.TriangulationAlgorithm.Seidel">
            <summary>
            Convex decomposition algorithm created by Raimund Seidel
            
            Properties:
            - Decompose the polygon into trapezoids, then triangulate.
            - To use the trapezoid data, use ConvexPartitionTrapezoid()
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n log n), n = number of vertices.
            - Running time is almost linear for most simple polygons.
            - Does not care about winding order. 
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Decomposition.TriangulationAlgorithm.Delauny">
            <summary>
            2D constrained Delaunay triangulation algorithm.
            Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
            
            Properties:
            - Creates triangles with a large interior angle.
            - Supports holes
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n^2), n = number of vertices.
            - Does not care about winding order.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.LineTools">
            <summary>
            Collection of helper methods for misc collisions.
            Does float tolerance and line collisions with lines and AABBs.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect2(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
             <summary>
            Check if the lines a0->a1 and b0->b1 cross.
            If they do, intersectionPoint will be filled
            with the point of crossing.
            
            Grazing lines should not return true.
             
             </summary>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="point">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.Vertices)">
            <summary>
            Get all intersections between a line segment and a list of vertices
            representing a polygon. The vertices reuse adjacent points, so for example
            edges one and two are between the first and second vertices and between the
            second and third vertices. The last edge is between vertex vertices.Count - 1
            and verts0. (ie, vertices from a Geometry or AABB)
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="vertices">The vertices, as described above</param>
        </member>
        <member name="M:FarseerPhysics.Common.LineTools.LineSegmentAABBIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Collision.AABB)">
            <summary>
            Get all intersections between a line segment and an AABB. 
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="aabb">The AABB that is used for testing intersection.</param>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Cross(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            Perform the cross product on two vectors.
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Mul(FarseerPhysics.Common.Mat33,Microsoft.Xna.Framework.Vector3)">
            Multiply a matrix times a vector.
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Mul22(FarseerPhysics.Common.Mat33,Microsoft.Xna.Framework.Vector2)">
            Multiply a matrix times a vector.
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Mul(FarseerPhysics.Common.Rot,FarseerPhysics.Common.Rot)">
            Multiply two rotations: q * r
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.MulT(FarseerPhysics.Common.Rot,FarseerPhysics.Common.Rot)">
            Transpose multiply two rotations: qT * r
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Mul(FarseerPhysics.Common.Rot,Microsoft.Xna.Framework.Vector2)">
            Rotate a vector
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.MulT(FarseerPhysics.Common.Rot,Microsoft.Xna.Framework.Vector2)">
            Inverse rotate a vector
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Skew(Microsoft.Xna.Framework.Vector2)">
            Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.IsValid(System.Single)">
            <summary>
            This function is used to ensure that a floating point number is
            not a NaN or infinity.
            </summary>
            <param name="x">The x.</param>
            <returns>
            	<c>true</c> if the specified x is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.InvSqrt(System.Single)">
            <summary>
            This is a approximate yet fast inverse square-root.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.VectorAngle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Dot(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            Perform the dot product on two vectors.
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.IsCollinear(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            Determines if three vertices are collinear (ie. on a straight line)
            </summary>
            <param name="a">First vertex</param>
            <param name="b">Second vertex</param>
            <param name="c">Third vertex</param>
            <param name="tolerance">The tolerance</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is equal to another,
            within a certain tolerance.
            </summary>
            <param name="value1">The first floating point Value.</param>
            <param name="value2">The second floating point Value.</param>
            <param name="delta">The floating point tolerance.</param>
            <returns>True if the values are "equal", false otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is within a specified
            range of values (inclusive).
            </summary>
            <param name="value">The Value to check.</param>
            <param name="min">The minimum Value.</param>
            <param name="max">The maximum Value.</param>
            <returns>True if the Value is within the range specified,
            false otherwise.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.Mat22">
            <summary>
            A 2-by-2 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct this matrix using scalars.
            </summary>
            <param name="a11">The a11.</param>
            <param name="a12">The a12.</param>
            <param name="a21">The a21.</param>
            <param name="a22">The a22.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetIdentity">
            <summary>
            Set this to the identity matrix.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat22.Solve(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Common.Mat33">
            <summary>
            A 3-by-3 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
            <param name="c3">The c3.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve33(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.Solve22(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases. Solve only the upper
            2-by-2 matrix equation.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.GetInverse22(FarseerPhysics.Common.Mat33@)">
            Get the inverse of this matrix as a 2-by-2.
            Returns the zero matrix if singular.
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.GetSymInverse33(FarseerPhysics.Common.Mat33@)">
            Get the symmetric inverse of this matrix as a 3-by-3.
            Returns the zero matrix if singular.
        </member>
        <member name="M:FarseerPhysics.Common.Mat33.GetInverse22(FarseerPhysics.Common.Mat33)">
            Get the inverse of this matrix as a 2-by-2.
            Returns the zero matrix if singular.
        </member>
        <member name="T:FarseerPhysics.Common.Rot">
            Rotation
        </member>
        <member name="M:FarseerPhysics.Common.Rot.#ctor(System.Single)">
            Initialize from an angle in radians
        </member>
        <member name="M:FarseerPhysics.Common.Rot.Set(System.Single)">
            Set using an angle in radians.
        </member>
        <member name="M:FarseerPhysics.Common.Rot.SetIdentity">
            Set to the identity rotation
        </member>
        <member name="M:FarseerPhysics.Common.Rot.GetAngle">
            Get the angle in radians
        </member>
        <member name="M:FarseerPhysics.Common.Rot.GetXAxis">
            Get the x-axis
        </member>
        <member name="M:FarseerPhysics.Common.Rot.GetYAxis">
            Get the u-axis
        </member>
        <member name="F:FarseerPhysics.Common.Rot.s">
            Sine and cosine
        </member>
        <member name="F:FarseerPhysics.Common.Rot.c">
            Sine and cosine
        </member>
        <member name="T:FarseerPhysics.Common.Transform">
            <summary>
            A transform contains translation and rotation. It is used to represent
            the position and orientation of rigid frames.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.#ctor(Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.Rot@)">
            <summary>
            Initialize using a position vector and a rotation matrix.
            </summary>
            <param name="position">The position.</param>
            <param name="rotation">The r.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.SetIdentity">
            <summary>
            Set this to the identity transform.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Transform.Set(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Set this based on the position and angle.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
        </member>
        <member name="T:FarseerPhysics.Common.Sweep">
            <summary>
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.A">
            <summary>
            World angles
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.Alpha0">
            <summary>
            Fraction of the current time step in the range [0,1]
            c0 and a0 are the positions at alpha0.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.C">
            <summary>
            Center world positions
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Sweep.LocalCenter">
            <summary>
            Local center of mass position
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.GetTransform(FarseerPhysics.Common.Transform@,System.Single)">
            <summary>
            Get the interpolated transform at a specific time.
            </summary>
            <param name="xfb">The transform.</param>
            <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Advance(System.Single)">
            <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
            <param name="alpha">new initial time..</param>
        </member>
        <member name="M:FarseerPhysics.Common.Sweep.Normalize">
            <summary>
            Normalize the angles.
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.Path">
            <summary>
            Path:
            Very similar to Vertices, but this
            class contains vectors describing
            control points on a Catmull-Rom
            curve.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.Path.ControlPoints">
            <summary>
            All the points that makes up the curve
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector2})">
            <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.NextIndex(System.Int32)">
            <summary>
            Gets the next index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the control points by the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the control points by the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.Rotate(System.Single)">
            <summary>
            Rotate the control points by the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetVertices(System.Int32)">
            <summary>
            Returns a set of points defining the
            curve with the specifed number of divisions
            between each control point.
            </summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.Path.GetPositionNormal(System.Single)">
            <summary>
            Gets the normal for the given time.
            </summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="P:FarseerPhysics.Common.Path.Closed">
            <summary>
            True if the curve is closed.
            </summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:FarseerPhysics.Common.PathManager">
            <summary>
            An easy to use manager for creating paths.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.ConvertPathToEdges(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Int32)">
            <summary>
            Convert a path into a set of edges and attaches them to the specified body.
            Note: use only for static edges.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.ConvertPathToPolygon(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Int32)">
            <summary>
            Convert a closed path into a polygon.
            Convex decomposition is automatically performed.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,System.Collections.Generic.IEnumerable{FarseerPhysics.Collision.Shapes.Shape},FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,FarseerPhysics.Collision.Shapes.Shape,FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.MoveBodyOnPath(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>
            Moves the given body along the defined path.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PathManager.AttachBodiesWithRevoluteJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="T:FarseerPhysics.Common.PhysicsLogic.FilterData">
            <summary>
            Contains filter data that can determine whether an object should be processed or not.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.FilterData.DisabledOnCategories">
            <summary>
            Disable the logic on specific categories.
            Category.None by default.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.FilterData.DisabledOnGroup">
            <summary>
            Disable the logic on specific groups
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.FilterData.EnabledOnCategories">
            <summary>
            Enable the logic on specific categories
            Category.All by default.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.FilterData.EnabledOnGroup">
            <summary>
            Enable the logic on specific groups.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.IsActiveOn(FarseerPhysics.Dynamics.Body)">
            <summary>
            
            </summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.AddDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.RemoveDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.IsInDisabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.AddEnabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.RemoveEnabledCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.FilterData.IsInEnabledInCategory(FarseerPhysics.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IgnorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.RestorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Restore the controller. The controller affects this body.
            </summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IsPhysicsLogicIgnored(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="type">The logic type.</param>
            <returns>
            	<c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:FarseerPhysics.Common.PhysicsLogic.RayDataComparer">
            <summary>
            This is a comprarer used for 
            detecting angle difference between rays
            </summary>
        </member>
        <member name="T:FarseerPhysics.Common.PhysicsLogic.RealExplosion">
            <summary>
            Creates a realistic explosion based on raycasting. Objects in the open will be affected, but objects behind
            static bodies will not. A body that is half in cover, half in the open will get half the force applied to the end in
            the open.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.MaxEdgeOffset">
            <summary>
            Two degrees: maximum angle from edges to first ray tested
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.EdgeRatio">
            <summary>
            Ratio of arc length to angle from edges to first ray tested.
            Defaults to 1/40.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.IgnoreWhenInsideShape">
            <summary>
            Ignore Explosion if it happens inside a shape.
            Default value is false.
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.MaxAngle">
            <summary>
            Max angle between rays (used when segment is large).
            Defaults to 15 degrees
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.MaxShapes">
            <summary>
            Maximum number of shapes involved in the explosion.
            Defaults to 100
            </summary>
        </member>
        <member name="F:FarseerPhysics.Common.PhysicsLogic.RealExplosion.MinRays">
            <summary>
            How many rays per shape/body/segment.
            Defaults to 5
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.RealExplosion.Activate(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Activate the explosion at the specified position.
            </summary>
            <param name="pos">The position where the explosion happens </param>
            <param name="radius">The explosion radius </param>
            <param name="maxForce">The explosion force at the explosion point (then is inversely proportional to the square of the distance)</param>
            <returns>A list of bodies and the amount of force that was applied to them.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.PhysicsLogic.SimpleExplosion">
            <summary>
            Creates a simple explosion that ignores other bodies hiding behind static bodies.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PhysicsLogic.SimpleExplosion.Activate(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Activate the explosion at the specified position.
            </summary>
            <param name="pos">The position (center) of the explosion.</param>
            <param name="radius">The radius of the explosion.</param>
            <param name="force">The force applied</param>
            <param name="maxForce">A maximum amount of force. When force gets over this value, it will be equal to maxForce</param>
            <returns>A list of bodies and the amount of force that was applied to them.</returns>
        </member>
        <member name="P:FarseerPhysics.Common.PhysicsLogic.SimpleExplosion.Power">
            <summary>
            This is the power used in the power function. A value of 1 means the force
            applied to bodies in the explosion is linear. A value of 2 means it is exponential.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(FarseerPhysics.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Split a fixture into 2 vertice collections using the given entry and exit-point.
            </summary>
            <param name="fixture">The Fixture to split</param>
            <param name="entryPoint">The entry point - The start point</param>
            <param name="exitPoint">The exit point - The end point</param>
            <param name="first">The first collection of vertexes</param>
            <param name="second">The second collection of vertexes</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.Cut(FarseerPhysics.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This is a high-level function to cuts fixtures inside the given world, using the start and end points.
            Note: We don't support cutting when the start or end is inside a shape.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The startpoint.</param>
            <param name="end">The endpoint.</param>
            <returns>True if the cut was performed.</returns>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.SimpleCombiner">
            <summary>
            Combines a list of triangles into a list of convex polygons.
            Starts with a seed triangle, keep adding triangles to it until you can't add any more without making the polygon non-convex.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimpleCombiner.PolygonizeTriangles(System.Collections.Generic.List{FarseerPhysics.Common.Vertices},System.Int32,System.Single)">
             <summary>
             Combine a list of triangles into a list of convex polygons.
             
             Note: This only works on triangles.
             </summary>
            <param name="triangles">The triangles.</param>
            <param name="maxPolys">The maximun number of polygons to return.</param>
            <param name="tolerance">The tolerance</param>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.SimplifyTools">
            <summary>
            Provides a set of tools to simplify polygons in various ways.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Removes all collinear points on the polygon.
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <param name="collinearityTolerance">The collinearity tolerance.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
            speed-up technique by using the Melkman convex hull.
            
            If you pass in 0, it will remove all collinear points.
            </summary>
            <returns>The simplified polygon</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeParallelEdges(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Merges all parallel edges in the list of vertices
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeIdenticalPoints(FarseerPhysics.Common.Vertices)">
            <summary>
            Merges the identical points in the polygon.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Reduces the polygon by distance.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="distance">The distance between points. Points closer than this will be removed.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByNth(FarseerPhysics.Common.Vertices,System.Int32)">
            <summary>
            Reduces the polygon by removing the Nth vertex in the vertices list.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="nth">The Nth point to remove. Example: 5.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByArea(FarseerPhysics.Common.Vertices,System.Single)">
            <summary>
            Simplify the polygon by removing all points that in pairs of 3 have an area less than the tolerance.
            
            Pass in 0 as tolerance, and it will only remove collinear points.
            </summary>
            <param name="vertices"></param>
            <param name="areaTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyClipType,FarseerPhysics.Common.PolygonManipulation.PolyClipError@)">
            <summary>
            Implements "A new algorithm for Boolean operations on general polygons" 
            available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
            Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
            self-intersecting.
            
            Warning: May yield incorrect results or even crash if polygons contain collinear points.
            </summary>
            <param name="subject">The subject polygon.</param>
            <param name="clip">The clip polygon, which is added, 
            substracted or intersected with the subject</param>
            <param name="clipType">The operation to be performed. Either
            Union, Difference or Intersection.</param>
            <param name="error">The error generated (if any)</param>
            <returns>A list of closed polygons, which make up the result of the clipping operation.
            Outer contours are ordered counter clockwise, holes are ordered clockwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
            <summary>
            Calculates all intersections between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
            <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(FarseerPhysics.Common.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the simplical chain corresponding to the input polygon.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},FarseerPhysics.Common.PolygonManipulation.PolyClipType,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the characteristics function for all edges of
            the given simplical chains and builds the result chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{FarseerPhysics.Common.Vertices}@)">
            <summary>
            Calculates the polygon(s) from the result simplical chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge,System.Single)">
            <summary>
            Needed to calculate the characteristics function of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Needed for sorting multiple intersections points on the same edge.
            </summary>
            <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns the coefficient of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)">
            <summary>
            Winding number test for a point in a simplex.
            </summary>
            <param name="point">The point to be tested.</param>
            <param name="edge">The edge that the point is tested against.</param>
            <returns>False if the winding number is even and the point is outside
            the simplex and True otherwise.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Tests if a point lies on a line segment.
            </summary>
            <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
        </member>
        <member name="T:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge">
            <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
            <param name="center">the center of the box in local coordinates.</param>
            <param name="angle">the rotation of the box in local coordinates.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Creates a rounded rectangle with the specified width and height.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The rounding X radius.</param>
            <param name="yRadius">The rounding Y radius.</param>
            <param name="segments">The number of segments to subdivide the edges.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateLine(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as a single edge.
            </summary>
            <param name="start">The first point.</param>
            <param name="end">The second point.</param>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCircle(System.Single,System.Int32)">
            <summary>
            Creates a circle with the specified radius and number of edges.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateEllipse(System.Single,System.Single,System.Int32)">
            <summary>
            Creates a ellipse with the specified width, height and number of edges.
            </summary>
            <param name="xRadius">Width of the ellipse.</param>
            <param name="yRadius">Height of the ellipse.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
            <param name="endRadius">Radius of the capsule ends.</param>
            <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified  height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + radii) of the capsule.</param>
            <param name="topRadius">Radius of the top.</param>
            <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
            <param name="bottomRadius">Radius of bottom.</param>
            <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a gear shape with the specified radius and number of teeth.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfTeeth">The number of teeth.</param>
            <param name="tipPercentage">The tip percentage.</param>
            <param name="toothHeight">Height of the tooth.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="T:FarseerPhysics.Common.WorldSerializer">
            <summary>
            Serialize the world into an XML file
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.WorldSerializer.Serialize(FarseerPhysics.Dynamics.World,System.String)">
            <summary>
            Serialize the world to an XML file
            </summary>
            <param name="world"></param>
            <param name="filename"></param>
        </member>
        <member name="M:FarseerPhysics.Common.WorldSerializer.Deserialize(System.String)">
            <summary>
            Deserialize the world from an XML file
            </summary>
            <param name="filename"></param>
        </member>
        <member name="T:FarseerPhysics.Common.Stopwatch">
            <summary>
            An emulation for the Stopwatch class for Windows Phone and Silverlight.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Stopwatch.StartNew">
            <summary>
            Creates a new instance of the class and starts the watch immediately.
            </summary>
            <returns>An instance of Stopwatch, running.</returns>
        </member>
        <member name="M:FarseerPhysics.Common.Stopwatch.#ctor">
            <summary>
            Creates an instance of the Stopwatch class.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Stopwatch.Reset">
            <summary>
            Completely resets and deactivates the timer.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Stopwatch.Start">
            <summary>
            Begins the timer.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.Stopwatch.Stop">
            <summary>
            Stops the current timer.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.Stopwatch.IsRunning">
            <summary>
            Gets a value indicating whether the instance is currently recording.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.Stopwatch.Elapsed">
            <summary>
            Gets the Elapsed time as a Timespan.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.Stopwatch.ElapsedMilliseconds">
            <summary>
            Gets the Elapsed time as the total number of milliseconds.
            </summary>
        </member>
        <member name="P:FarseerPhysics.Common.Stopwatch.ElapsedTicks">
            <summary>
            Gets the Elapsed time as the total number of ticks (which is faked
            as Silverlight doesn't have a way to get at the actual "Ticks")
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.DetectSquares(FarseerPhysics.Collision.AABB,System.Single,System.Single,System.SByte[0:,0:],System.Int32,System.Boolean)">
             <summary>
             Marching squares over the given domain using the mesh defined via the dimensions
                (wid,hei) to build a set of polygons such that f(x,y) less than 0, using the given number
                'bin' for recursive linear inteprolation along cell boundaries.
            
                if 'comb' is true, then the polygons will also be composited into larger possible concave
                polygons.
             </summary>
             <param name="domain"></param>
             <param name="cellWidth"></param>
             <param name="cellHeight"></param>
             <param name="f"></param>
             <param name="lerpCount"></param>
             <param name="combine"></param>
             <returns></returns>
        </member>
        <member name="F:FarseerPhysics.Common.TextureTools.MarchingSquares._lookMarch">
            Linearly interpolate between (x0 to x1) given a value at these coordinates (v0 and v1)
                        such as to approximate value(return) = 0
                    *
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.Xlerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.Ylerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.Square(System.Single)">
            Square value for use in marching squares *
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.MarchSquare(System.SByte[0:,0:],System.SByte[0:,0:],FarseerPhysics.Common.TextureTools.MarchingSquares.GeomPoly@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Perform a single celled marching square for for the given cell defined by (x0,y0) (x1,y1)
                        using the function f for recursive interpolation, given the look-up table 'fs' of
                        the values of 'f' at cell vertices with the result to be stored in 'poly' given the actual
                        coordinates of 'ax' 'ay' in the marching squares mesh.
                    *
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.combLeft(FarseerPhysics.Common.TextureTools.MarchingSquares.GeomPoly@,FarseerPhysics.Common.TextureTools.MarchingSquares.GeomPoly@)">
            Used in polygon composition to composit polygons into scan lines
                        Combining polya and polyb into one super-polygon stored in polya.
                    *
        </member>
        <member name="T:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1">
            <summary>
            Designed as a complete port of CxFastList from CxStd.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Begin">
            <summary>
            Iterator to start of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.End">
            <summary>
            Iterator to end of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Front">
            <summary>
            Returns first element of list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Add(`0)">
            <summary>
            add object to list (O(1))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Remove(`0)">
            <summary>
            remove object from list, returns true if an element was removed (O(n))
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Pop">
            <summary>
            pop element from head of list (O(1)) Note: this does not return the object popped! 
            There is good reason to this, and it regards the Alloc list variants which guarantee 
            objects are released to the object pool. You do not want to retrieve an element 
            through pop or else that object may suddenly be used by another piece of code which 
            retrieves it from the object pool.
            </summary>
        </member>
        <member name="M:FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastList`1.Insert(FarseerPhysics.Common.TextureTools.MarchingSquares.CxFastListNode{`0},`0)">
            <summary>
            insert object after 'node' returning an iterator to the inserted object.
            </summary>
        </member>
